# [노말틱 모의 해킹 취업반 스터디 8기 1개월 3주차 강의 & 실습]

> **원본 포스트 ID**: 29
> **발행일**: 2025-04-15 22:53:00
> **카테고리**: 해킹공부/노말틱 취업반

## 📝 원문 내용

**라이브 코칭**

**where 구문의 논리 구조**

where (1=1)참 and (1=2)거짓 → 거짓

where (1=1) and (1=2) or (1=1) → (1=1)은 참 (1=2)는 거짓 참 and 거짓 → 거짓 or 참 → 참

  
**연산은 순서대로 x**   
and 와 or에는 우선 순위 있음 (and가 or 보다 우선)

ex) 1+2*3 이연산은 더하기보다 곱하기를 먼저한다

where (1=1) or (1=1) and (1=2) → 참

**괄호가 있다면 괄호 먼저**   
where ((1=1) or (1=2)) and (2=1)

**Q &A**

"SELECT 문은 객체를 반환하고, INSERT 문은 boolean을 반환하더라고요,   
저는 이걸 조건문으로 이용해서, 회원가입성공여부를 판단하는데 활용했는데, 혹시 조건문말고 다른 방식으로 활용할 수 있는 예가 있을까요?"   
SQL : insert >>> 1,0   
  
  
"HTML에서 input의 type을 password로 하면 입력값이 가려지잖아요.   
그런데 MySQL에도 그런 식으로 비밀번호가 자동으로 가려지거나,   
해시 처리되는 기능이 따로 있나요?"   
  
HTML password ****   
>web Browser   
  
MySQL > 1234 > **** 의미 없어짐   
DB안에는 없음   
HASH : 일방향함수   
MySQL hash function   
  
md5(".$_POST['pass'].")   
  
추가로, insert하는 구문에서, where id='$id' 라고 주니까, 재미삼아 해본 인젝션에 뚫리던데, 사용자로 부터 받는 입력값을 바로 넣지 않는 방법도 있나요?   
  
나중에   
PreparedStatement   
  
따라는 갔는데 프로그램이 동작을 안합니다 이유를 모르겠심더   
  
안됨   
  
DB에 데이터 넣었다가 지웠는데 다음 데이터를 넣으니 idx가 지웠던 이후 번호로 나오는데 왜 그런건가요?   
mysql auto increament   
  
과제 하면서 header 함수를 사용해서 페이지 이동을 하려고 했는데 header already sent 라고 뜨며 에러가 떴습니다. 찾아보니 화면에 output이 있어서 그렇다고 하는데 왜 그런걸까요?   
  
이미 있는데 또있으니까   
  
별건 아닙니다만   
mysqli_fetch_array() 를 수업때 사용하셨는데   
assoc 말고 사용하신 이유가 있나요?   
  
별다른 이유 없음   
  
array가 row방식과 assoc방식 둘다 불러온다는건 알고 있습니다 특별한 이유가 있어서 인지 궁금해서 남깁니다 (실무 관련인가? 등등)   
  
DB 접속계정 정보가 노출되는게 불편해서 db_config.php 파일을 별도로 만들고 다른 파일에서 해당 파일을 include 하는 형태로 했는데 db_config.php에도 비밀번호가 그대로 노출되어 있으니 암호화해서 파일에 저장하고 db접속할 때 인코딩된 정보를 통해 접속하게 하는 방법이 있을까요   
  
그걸 구현하는 방법은 있음 데이터베이스에 비밀번호를 가릴수있는 방법이 없음   
php언어로 암호화하는 방법은 있음   
  
404 error.. ls, 오타, ip, 포트, 인터넷, phpmyadmin, apache 모두 괜찮습니다만 VM에서 새로 만든 db_test.php 파일이 안열려서 실습자체가 불가능했습니다...   
지금은 하드코딩으로 PHP파일 내부에 데이터베이스 로그인을 위한 ROOT와 그 비밀번호를 변수에 DEFINE 해놓고 썼습니다.   
전역설정을 통해서 다른 PHP파일에는 따로 선언 없이 다른사람은 접근하기 어렵게 하되 관리자는 그걸 수정하거나 쉽게 사용할 수 있는 방법이 있을까요?   
  
php에러가 나면 > 디버깅!> 문제 원인 파악!   
  
어떻게 안열리는지 500?> 어떤 코드가 문제인지   
  
지금은 하드코딩으로 PHP파일 내부에 데이터베이스 로그인을 위한 ROOT와 그 비밀번호를 변수에 DEFINE 해놓고 썼습니다.   
전역설정을 통해서 다른 PHP파일에는 따로 선언 없이 다른사람은 접근하기 어렵게 하되 관리자는 그걸 수정하거나 쉽게 사용할 수 있는 방법이 있을까요   
  
없는걸로 알고있음 > 블루트스 샤워기   
  
웹서버의 Shell이 털렸다는 것은 무조건 DB도 털렸다는 것. 털리지 않으면 해커가 착한 거라고 말씀하셨는데   
여기서 말씀하시는 웹서버가 정확히 웹서버일까요? 아니면 WAS서버인걸까요?   
만약 웹서버와 WAS가 구분되어있고, 웹서버나 WAS 서버 중 하나의 Shell 만 뚫렸어도 DB가 털리는게 자명한걸까요?   
  
>정확히 말하면 WAS   
  
WAS가 SQL의 명령을 날림   
WAS에는 DB계정이 있음 권한이 있기 때문에   
  
WEB이 털렸을뗀?? 그렇지 않음   
  
webserver에는 WAS의 권한이 있음   
  
sql injection 공격에 당하지 않게 작성하는 방법은 어떤건가요?   
  
SQL Injection > 어떻게 일어나는지!   
  
비밀번호를 해시값으로 DB서버에 저장하면 쉘을 따도 평문은 알 수가 없나요?   
  
평문 할수없음   
  
근래에도 SQLi 공격으로 해킹되는 사례가 많은가요?   
  
많음

* * *

**3주차 강의**

**로그인은 식별과 인증의 조합이다**.

  * 식별(identification) : 누구지 알아보는 과정 ☞ ID,전화번호,이메일 등
  * 인증(Authentication) : 정말 그 사람이 맞는지 검증하는 과정 ☞ 비밀번호,OTP등



ex) 홍길동이라는 이름은 식별 정보,그 사람의 주민번호나 비밀번호는 인증 정보다.

식별 정보는 겹치면 안 된다.

  * 보통 ID는 Primary Key로 저장되며 절대 중복되지 않아야 함
  * 이름이나 닉네임은 중복 가능하지만 Id는 고유해야 시스템이 식별 가능



**식별**

정의 

사용자가 누구인지 나타내는 과정

서버가 사용자에게 "너 누구야?" 라고 물어보는 단계

예시 

  * 로그인 시 입력하는 아이디(ID)
  * 이메일 주소
  * 사번,전화번호 등도 식별 정보가 될 수 있음



특정

  * 고유해야 함 ☞ 중복되면 안 됨
  * 그 사람을 찾기 위한 "라벨" 같은 거
  * 하지만 식별 정보만으로는 로그인 처리를 하면 안 됨 (왜냐면 누구나 알 수 있으니까)



**인증**

정의 

사용자가 진짜 그 사람인지 검증하는 과정.

서버가 사용자에게 "그게 진짜 너 맞아?" 하고 확인하는 단계.

예시

  * 비밀번호 입력
  * OTP(문자 인증번호)
  * 생체 인증(지문, 얼굴 인식)
  * 인증서, 지갑 서명등



특징

  * 식별 정보와 짝지어져야 의미가 있음
  * 비밀정보여야함 
  * 인증이 실패하면 "접근 거부" 가 되는 핵심 로직

구분 | 식별(identification) | 인증(Authentication)  
---|---|---  
질문 | 너 누구야  | 진짜 너 맞아  
목적 | 사용자를 찾기 위해서 | 해당 사용자의 본인 여부 확인  
예시  | 아이디, 이메일, 사번 등 | 비밀번호, OTP, 생체 인증 등  
보안성  | 낮음(공개된 수 있음) | 높음 (노출되면 안 됨)  
  
**쿠키 vs 세션 vs 세션ID**

구분 | 쿠키 | 세션 | 세션ID  
---|---|---|---  
저장 위치 | 브라우저 | 서버 | 브라우저 (쿠키에 저장됨)  
용도 | 자동 로그인,사용자 설정 저장 | 로그인 상태 유지  | 세션을 구별하는 키값  
보안 위함 | 조작,탈취 가능 | 세션ID가 탈취되면 위험 | 탈취되면 로그인 없이도 접근 가능  
  
**쿠키 (Cookie)** ?

  * 클라이언트가 가지고 있는 데이터
  * 예전 대학 사이트들 : 쿠키만 조작해서 다른 계정 로그인 가능했던 시절도 있었음



쿠키의 취약점 :

쿠키 탈취

어떤 취약점인가?

사용자의 세션ID 쿠키를 탈취하면,해당 사용자의 로그인 상태를 가로챌 수 있음

탈취 방법

  * XSS로 document.cookie 탈취
  * HTTP 통신 시 **중간자 공격(MITM)**으로 가로채기 (HTTPS 안 쓰면 가능)
  * 악성 브라우저 확장 프로그램이 쿠키 수집



대응방법

로그인 시 세션ID 재발급

세션 타임아웃 설정 (예: 은행 3분 자동 로그아웃)

**세션**

  * 서버가 로그인한 사용자의 정보는 저장하는 공간
  * PHP 예시 :


    
    
    session_start();
    $_SESSION['id'] = 'normaltic';

**세션ID**

  * 쿠키에 PHPSESSID = abd123wdqssxzc 같은 랜덤 값이 들어감 
  * 서버는 이 ID를 보고 세션 정보 로딩



세션ID 탈취란?

어떤 일이 벌어지나?

  * 세션ID는 **로그인 인증의 증표**
  * 누군가 이걸 **탈취해서 자신의 쿠키에 넣으면** , 로그인 없이도 남의 계정처럼 사용 가능



실제 사례

  * 유명 스트리머 쫀득님 계정 해킹: **세션ID 탈취**
  * 네이버/유튜브 해킹 시도에도 자주 사용됨



<https://youtu.be/KRtH7TQX5Yw?si=ADXem5s-RYBZ75kQ>

방어 방법

  * 세션ID를 매번 로그인 시 **새로 발급**
  * 일정 시간 지나면 세션 만료 (예: 은행 3분 자동 로그아웃)
  * HttpOnly, Secure, SameSite 쿠키 옵션 설정
  * HTTPS 사용 필수



**HASH**

원본 데이터를 일정한 규칙으로 바꿔서, 고정된 길이의 문자열로 변환하는 일방향 암호화 방식

Hash의 3가지 핵심 특징

특징  | 설명  
---|---  
일방향성 | 해시된 값을 절대 원래대로 되돌릴 수 없음 (복호화 불가)  
고정된 길이 | 아무리 긴 데이터를 넣어도 결과값은 항상 일정한 길이  
충돌 회피 | 서로 다른 입력값이 같은 해시를 만들면 안 됨 (출돌 = 위험)  
  
비밍번호 저장에 해시를 써야하는 이유
    
    
    INSERT INTO member (id, pass) VALUES ('user1', '1234');

이런식으로 쓰면 해킹당하면 다 노출됨
    
    
    $pw_hash = password_hash('1234', PASSWORD_DEFAULT);
    
    if(password_verify('1234', $pw_hash)){
      // 로그인 성공
    }

하지만 해시를 사용해서 쓰면 DB에는 1234가 아닌 해시값이 저장됨 

서버는 로그인할 때마다 입력값을 해시로 변환 후 비교함

**대표적인 해시 알고리즘**

알고리즘 | 설명 | 보안성 | 사용 예  
---|---|---|---  
MD5 | 오래된 알고리즘 | 낮음 (충돌 발생) | 예전 웹사이트  
SHA-1 | MD5보다 개선됨 | 낮음 (더 이상 사용 권장 X) | 일부 구식 시스템  
SHA-256 | 보안성 높음 | 좋음  | JWT 서명 등  
bcrypt | 비밀번호 해시에 특화 | 매우 좋음 | password_hash()  
argon2 | 최신 알고리즘 | 최고 보안 수준  | 비밀번호 보관용 (권장)  
  
**해시 vs 암호화 vs 인코딩**

구분 | 해시 | 암호화  | 인코딩  
---|---|---|---  
목적 | 무결성, 비밀번호 보안 | 기밀성 (내용 숨기기) | 데이터 변환  
복호화 가능? | 불가능 | 가능 (Key 필요) | 가능  
사용 예 | 비밀번호 저장 | HTTPS, 파일 암호화 | URL, Base64  
  
해서만 쓰면 100% 안전할까?

단순 해시만 하면 해커가 **딕셔너리 공격** 이나 **무차별 대입 공격(Brute-force)**으로 쉽게 맞출 수 있음.

**웹 로그인 과정 전체 흐름**

**① 로그인 요청**

사용자가 로그인 폼에 ID/PW를 입력하고 제출

**② 식별**

ID를 기준으로 "누구인지 확인"
    
    
    SELECT * FROM users WHERE id = '___';

  * DB에 사용자가 있는지 확인하는 단계 
  * ID는 노출되어도 괜찮은 정보



**③ 인증**

해당 ID의 비밀번호가 맞는지 확인 
    
    
    if (password_verify($입력한_비번, $DB에서_가져온_해시값)) {
      // 인증 성공
    }

  * 비밀번호는 반드시 해시된 상태로 DB에 저장되어 있어야 함
  * 인증 성공하면 ☞ 사용자 정보 기억할 준비



**④ 세션 생성 (서버 내부)**
    
    
    session_start();
    $_SESSION['user_id'] = 'hike';

  * 서버가 메모리 또는 파일에 세션 저장 
  * 이 세션에 사용자의 로그인 상태, 권한 정보 등을 담음



**⑤ 세션ID 발급 + 쿠키에 저장**

세션을 구분할 수 있도록 랜덤한 문자열(sessionID)를 쿠키로 브라우저에 전달
    
    
    Set-Cookie: PHPSESSID=abc123xyz; HttpOnly; Secure;

**⑥ 쿠키 전달 및 자동 포함**

브라우저는 다음 요청부터 이 쿠키(sessionID)를 자동으로 서버에 보내좀
    
    
    Cookie: PHPSESSID=abc123xyz

**⑦ 서버는 세션ID로 로그인 상태 유지**

  * 서버는 쿠키로 받은 PHPSESSID를 보고 어떤 사용자인지 판단
  * 로그인한 상태로 계속 작동 가능



**위 내용 옵시디언으로 그림 그려보기**

![](./img/29_img.png)


## 🔗 제텔카스텐 연결

### 관련 개념
- [[]]
- [[]]

### 프로젝트 연결
- [[]]

### 학습 포인트
-

## 📋 액션 아이템
- [ ]
- [ ]

## 💡 개인적 통찰



---

**태그**: #해킹공부노말틱취업반
**상태**: 🌱 씨앗 (제텔카스텐 통합 대기)
**변환일**: 2025-10-07
