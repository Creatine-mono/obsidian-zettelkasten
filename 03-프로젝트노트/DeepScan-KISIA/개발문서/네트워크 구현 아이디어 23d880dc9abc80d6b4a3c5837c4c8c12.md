# 네트워크 구현 아이디어

### **샘플의 형식에 따르지 않아도 됨*

---

### 샘플1

1. 문자 정규화	O → 0, 하나 → 1, three → 3 등 치환
2. 패턴 탐지	정규표현식으로 전화번호/주민번호 탐색
3. 이름 식별	사전 기반 또는 NER 모델 필요
4. 추가 개선	GlyphBERT 등으로 시각적 유사 문자 처리

---

### 샘플2

1. 문자 정규화

사전 기반 치환 대신, LLM에게 "OIㅇ - 하나2three" 같은 입력을 주고 의도된 원래 표현을 추론하도록 요청 (예: "이건 '010-123'일 가능성이 높음" 식으로 해석 가능)

1. 패턴 탐지

정규표현식 대신 LLM이 "이 문장에서 개인정보로 추정되는 전화번호/주민번호/이름을 모두 찾아줘"와 같은 자연어 명령으로 추출

3 이름 식별

LLM이 맥락을 기반으로 이름 후보를 식별 (예: "김하나는 사람 이름 같아" vs `"하나 둘 셋"은 숫자임)

4 추가 개선

LLM + Glyph 정보(예: GlyphBERT 등)를 결합하여 유사 문자나 오타를 정확히 식별하는 파이프라인 설계 가능 (예: "O"와 "ㅇ" 구분 어려운 경우 시각정보로 보완)

---

### 원채희

[중간자 복호화(TLS Inspection)](%EC%A4%91%EA%B0%84%EC%9E%90%20%EB%B3%B5%ED%98%B8%ED%99%94(TLS%20Inspection)%20240880dc9abc8063afa7d55ce1ba359d.md)

### 중간자 복호화 (SSL Inspection)

: 모든 트래픽을 복호화해서 본문까지 들여다봄

→ 본문 분석 후 민감한 프롬프트를 차단(AI 파트)

## 구현 방법 : TLS 키 로깅

- TLS 암호화 통신은 공개키/비밀키 방식으로 초기 핸드셰이크를 통해 세션 키 (pre-master key)를 생성
- 이 키로 이후의 **데이터를 대칭키 방식**으로 암호화하고 통신
- 이 세션 키만 있으면 **중간에서 복호화 장비 없이도** 암호문을 복호화할 수 있음

➡️ **SSLKEYLOGFILE** 환경변수를 설정하면, 브라우저가 생성한 세션 키를 특정 파일에 **자동으로 저장**함.

---

### 김유은

---

### 추강민

## 구현 참고자료

[https://semtul79.tistory.com/5](https://semtul79.tistory.com/5)

### **A. nginx + Lua (OpenResty) 활용**

nginx에 **Lua 스크립트**(lua-resty-http 등)를 연동하면

요청을 받을 때마다 **내부적으로 AI API에 HTTP subrequest**를 보내 검열,

허용된 경우에만 `proxy_pass`로 외부 HTTPS로 트래픽 전달

차단되면 nginx에서 곧바로 응답 반환

### **nginx.conf 예시**

```
nginx
복사편집
http {
    lua_shared_dict cache 10m;

    server {
        listen 8080;

        location / {
            # 1. Lua에서 AI API에 서브요청
            access_by_lua_block {
                local http = require "resty.http"
                local req_body = ngx.req.get_body_data()
                local httpc = http.new()
                local res, err = httpc:request_uri("http://127.0.0.1:5000/check", {
                    method = "POST",
                    body = req_body,
                    headers = {
                        ["Content-Type"] = "application/json",
                    },
                })

                if not res or res.status ~= 200 then
                    ngx.status = 500
                    ngx.say("AI API 에러")
                    ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
                end

                local cjson = require "cjson"
                local ai_result = cjson.decode(res.body)

                if not ai_result.allow then
                    ngx.status = 403
                    ngx.say("Blocked by AI")
                    ngx.exit(ngx.HTTP_FORBIDDEN)
                end
                -- 허용된 경우는 아래로 계속 진행
            }

            # 2. 허용된 경우 외부 HTTPS로 프록시
            proxy_pass https://external-server.com;
            proxy_set_header Host external-server.com;
        }
    }
}
```